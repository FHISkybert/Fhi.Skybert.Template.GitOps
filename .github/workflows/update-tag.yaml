name: Update Tag

on:
  workflow_dispatch:
    inputs:
      updates:
        description: 'JSON array of repository-tag pairs, e.g. [{"repository": "myapp/api", "tag": "v1.2.3"}, {"repository": "myapp/frontend", "tag": "v2.1.0"}]'
        required: true
        type: string
      env:
        description: 'Environment folder name'
        required: true
        type: string

jobs:
  update-tag:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Validate environment folder exists
        run: |
          if [ ! -d "${{ github.event.inputs.env }}" ]; then
            echo "Error: Environment folder '${{ github.event.inputs.env }}' does not exist"
            exit 1
          fi
          
          echo "Found environment folder: ${{ github.event.inputs.env }}"
          
      - name: Detect deployment method
        id: detect_method
        run: |
          ENV_DIR="${{ github.event.inputs.env }}"
          DEPLOYMENT_METHOD=""
          
          # Check for Helm
          if [ -f "$ENV_DIR/Chart.yaml" ] && [ -f "$ENV_DIR/values.yaml" ]; then
            DEPLOYMENT_METHOD="helm"
            echo "Detected Helm deployment (Chart.yaml + values.yaml)"
            
          # Check for Kustomize
          elif [ -f "$ENV_DIR/kustomization.yaml" ]; then
            DEPLOYMENT_METHOD="kustomize"
            echo "Detected Kustomize deployment (kustomization.yaml)"
            
          # Check for plain YAML (look for common Kubernetes resource files)
          else
            DEPLOYMENT_METHOD="yaml"
            echo "Defaulting to plain YAML deployment"
          fi
          
          echo "deployment_method=$DEPLOYMENT_METHOD" >> $GITHUB_OUTPUT

      - name: Parse and validate updates input
        id: parse_updates
        run: |
          UPDATES_JSON='${{ github.event.inputs.updates }}'
          echo "Parsing updates: $UPDATES_JSON"
          
          # Validate JSON format
          if ! echo "$UPDATES_JSON" | jq empty 2>/dev/null; then
            echo "Error: Invalid JSON format in updates input"
            exit 1
          fi
          
          # Validate each entry has repository and tag
          if ! echo "$UPDATES_JSON" | jq -e 'all(has("repository") and has("tag"))' >/dev/null; then
            echo "Error: Each update entry must have both 'repository' and 'tag' fields"
            exit 1
          fi
          
          echo "✅ JSON validation passed"
          echo "updates=$UPDATES_JSON" >> $GITHUB_OUTPUT
          
      - name: Update repository tags
        run: |
          ENV_DIR="${{ github.event.inputs.env }}"
          UPDATES_JSON='${{ steps.parse_updates.outputs.updates }}'
          
          echo "Updating repository tags in $ENV_DIR"
          echo "Updates to apply:"
          echo "$UPDATES_JSON" | jq -r '.[] | "  - Repository: \(.repository) -> Tag: \(.tag)"'

          # Find all YAML files in the environment directory
          YAML_FILES=$(find "$ENV_DIR" -name "*.yaml" -o -name "*.yml")

          if [ -z "$YAML_FILES" ]; then
          echo "No YAML files found in $ENV_DIR"
          exit 1
          fi

          echo ""
          echo "Found YAML files to process:"
          echo "$YAML_FILES"

          # Process each update
          echo "$UPDATES_JSON" | jq -c '.[]' | while read -r update; do
              REPOSITORY=$(echo "$update" | jq -r '.repository')
              NEW_TAG=$(echo "$update" | jq -r '.tag')

              echo ""
              echo "Processing: $REPOSITORY -> $NEW_TAG"

              UPDATED_ANY_FILE=false

              # Process each YAML file - use process substitution instead of pipe to avoid subshell
              while IFS= read -r yaml_file; do
                  if [ ! -f "$yaml_file" ]; then
                  continue
                  fi
                  
                  
                  # Method 1: Look for two-line format (repository: ... \n tag: ...)
                  REPO_TAG_BLOCKS=$(grep -n -A1 -B1 "repository:\|tag:" "$yaml_file" 2>/dev/null)
                  
                  if [ -n "$REPO_TAG_BLOCKS" ]; then
                      # Find the line number of the matching repository
                      REPO_LINE=$(echo "$REPO_TAG_BLOCKS" | grep "repository:" | grep "$REPOSITORY" | cut -d: -f1)
                      
                      if [ -n "$REPO_LINE" ]; then
                          # Find the corresponding tag line (should be the next line with "tag:")
                          TAG_LINE=$(echo "$REPO_TAG_BLOCKS" | grep "^$((REPO_LINE + 1)):.*tag:" | cut -d: -f1)
                          
                          if [ -n "$TAG_LINE" ]; then
                              echo "    Found two-line format in $yaml_file: repository at line $REPO_LINE, tag at line $TAG_LINE"
                              
                              # Use sed to update the specific tag line, preserving comments
                              sed -i "${TAG_LINE}s/\(tag: *\)[\"']*[^\"'# ]*[\"']*/\1\"$NEW_TAG\"/g" "$yaml_file"
                              echo "    ✅ Updated tag on line $TAG_LINE"
                              UPDATED_ANY_FILE=true
                              continue
                          fi
                      fi
                  fi
                  
                  # Method 2: Look for single-line image format (image: repository:tag)
                  IMAGE_LINES=$(grep -n "image:\|value:" "$yaml_file" 2>/dev/null)
                  
                  if [ -n "$IMAGE_LINES" ]; then
                      # Use process substitution to avoid subshell issue
                      while IFS=: read -r line_num line_content; do
                          # Check if this line contains the repository (fuzzy match)
                          if echo "$line_content" | grep -q "$REPOSITORY"; then
                          echo "    Found single-line image format in $yaml_file at line $line_num: $line_content"
                              # Handle formats like: image: repo:tag, image: "repo:tag", image: 'repo:tag'
                              # Use sed to replace the tag part, preserving quotes and whitespace
                              sed -i "${line_num}s/\(image:.*$REPOSITORY:\|value:.*$REPOSITORY:\)[^\"'[:space:]]*/\1$NEW_TAG/g" "$yaml_file"
                              echo "    ✅ Updated image tag on line $line_num"
                              UPDATED_ANY_FILE=true
                          fi
                      done < <(echo "$IMAGE_LINES")
                  fi
              done < <(echo "$YAML_FILES")

              if [ "$UPDATED_ANY_FILE" = "false" ]; then
                  echo "    ⚠️  Repository '$REPOSITORY' not found in any YAML files"
              fi
          done

          echo ""
          echo "Updated repository and tag occurrences:"
          echo "$YAML_FILES" | while read -r yaml_file; do
              if [ -f "$yaml_file" ]; then
                  echo "=== $yaml_file ==="
                  grep -n -A1 -B1 "repository:\|tag:\|image:" "$yaml_file" 2>/dev/null || echo "No repository/tag/image entries found"
                  echo ""
              fi
          done
          
      - name: Check if changes were made
        id: check_changes
        run: |
          if git diff --quiet; then
            echo "No changes were made to the files"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected:"
            git diff
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Commit and push changes
        if: steps.check_changes.outputs.changes_made == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "${{ github.event.inputs.env }}/"
          
          # Create commit message with all updates
          UPDATES_JSON='${{ steps.parse_updates.outputs.updates }}'
          COMMIT_MSG="Update tags in ${{ github.event.inputs.env }} environment"
          UPDATES_LIST=$(echo "$UPDATES_JSON" | jq -r '.[] | "- \(.repository): \(.tag)"')
          
          git commit -m "$COMMIT_MSG" -m "$UPDATES_LIST"
          git push
     
      - name: Summary
        run: |
          if [ "${{ steps.check_changes.outputs.changes_made }}" == "true" ]; then
            echo "✅ Successfully updated repository tags in ${{ github.event.inputs.env }}"
            UPDATES_JSON='${{ steps.parse_updates.outputs.updates }}'
            echo "Updates applied:"
            echo "$UPDATES_JSON" | jq -r '.[] | "  ✓ \(.repository) -> \(.tag)"'
          else
            echo "ℹ️ No changes were needed - all tags may already be set to the specified values"
          fi
          
      - name: Trigger OCI push workflow
        if: steps.check_changes.outputs.changes_made == 'true'
        run: |
          echo "Triggering OCI push workflow to rebuild manifests..."
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/oci-push.yaml/dispatches \
            -d '{"ref":"main"}'

