name: Update Tag

on:
  repository_dispatch:
    types: update_tag

jobs:
  update-tag:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse payload
        id: parse_payload
        run: |
          PAYLOAD='${{ toJson(github.event.client_payload) }}'
          echo "Raw payload: $PAYLOAD"
      
          # Validate payload is JSON
          if ! echo "$PAYLOAD" | jq empty 2>/dev/null; then
            echo "Error: Invalid JSON payload"
            exit 1
          fi
      
          # Extract env and updates
          ENV_DIR="$(echo "$PAYLOAD" | jq -r '.env')"
          UPDATES_JSON="$(echo "$PAYLOAD" | jq -c '.updates')"
      
          if [ -z "$ENV_DIR" ] || [ "$ENV_DIR" = "null" ]; then
            echo "Error: Missing 'env' in payload"
            exit 1
          fi
      
          # Ensure updates is an array and each item has repository+tag
          if ! echo "$UPDATES_JSON" | jq -e 'type=="array"' >/dev/null; then
            echo "Error: 'updates' must be an array"
            exit 1
          fi
          if ! echo "$UPDATES_JSON" | jq -e 'all(has("repository") and has("tag"))' >/dev/null; then
            echo "Error: Each update entry must have both \"repository\" and \"tag\""
            exit 1
          fi
      
          # Expose as step outputs
          echo "env=$ENV_DIR" >> "$GITHUB_OUTPUT"
          echo "updates=$UPDATES_JSON" >> "$GITHUB_OUTPUT"
          
      - name: Validate environment folder exists
        run: |
          if [ ! -d "${{ steps.parse_payload.outputs.env }}" ]; then
            echo "Error: Environment folder '${{ steps.parse_payload.outputs.env }}' does not exist"
            exit 1
          fi
          
          echo "Found environment folder: ${{ steps.parse_payload.outputs.env }}"
          
      - name: Detect deployment method
        id: detect_method
        run: |
          ENV_DIR='${{ steps.parse_payload.outputs.env }}'
          if [ -f "$ENV_DIR/Chart.yaml" ] && [ -f "$ENV_DIR/values.yaml" ]; then
            echo "deployment_method=helm" >> "$GITHUB_OUTPUT"
          elif [ -f "$ENV_DIR/kustomization.yaml" ]; then
            echo "deployment_method=kustomize" >> "$GITHUB_OUTPUT"
          else
            echo "deployment_method=yaml" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Update repository tags
        run: |
          ENV_DIR="${{ steps.parse_payload.outputs.env }}"
          UPDATES_JSON='${{ steps.parse_payload.outputs.updates }}'
          
          echo "Updating repository tags in $ENV_DIR"
          echo "Updates to apply:"
          echo "$UPDATES_JSON" | jq -r '.[] | "  - Repository: \(.repository) -> Tag: \(.tag)"'

          # Find all YAML files in the environment directory
          YAML_FILES=$(find "$ENV_DIR" -name "*.yaml" -o -name "*.yml")

          if [ -z "$YAML_FILES" ]; then
          echo "No YAML files found in $ENV_DIR"
          exit 1
          fi

          echo ""
          echo "Found YAML files to process:"
          echo "$YAML_FILES"

          # Process each update
          echo "$UPDATES_JSON" | jq -c '.[]' | while read -r update; do
              REPOSITORY=$(echo "$update" | jq -r '.repository')
              NEW_TAG=$(echo "$update" | jq -r '.tag')

              echo ""
              echo "Processing: $REPOSITORY -> $NEW_TAG"

              UPDATED_ANY_FILE=false

              # Process each YAML file - use process substitution instead of pipe to avoid subshell
              while IFS= read -r yaml_file; do
                  if [ ! -f "$yaml_file" ]; then
                  continue
                  fi
                  
                  
                  # Method 1: Look for two-line format (repository: ... \n tag: ...)
                  REPO_TAG_BLOCKS=$(grep -n -A1 -B1 "repository:\|tag:" "$yaml_file" 2>/dev/null)
                  
                  if [ -n "$REPO_TAG_BLOCKS" ]; then
                      # Find the line number of the matching repository
                      REPO_LINE=$(echo "$REPO_TAG_BLOCKS" | grep "repository:" | grep "$REPOSITORY" | cut -d: -f1)
                      
                      if [ -n "$REPO_LINE" ]; then
                          # Find the corresponding tag line (should be the next line with "tag:")
                          TAG_LINE=$(echo "$REPO_TAG_BLOCKS" | grep "^$((REPO_LINE + 1)):.*tag:" | cut -d: -f1)
                          
                          if [ -n "$TAG_LINE" ]; then
                              echo "    Found two-line format in $yaml_file: repository at line $REPO_LINE, tag at line $TAG_LINE"
                              
                              # Use sed to update the specific tag line, preserving comments
                              sed -i "${TAG_LINE}s/\(tag: *\)[\"']*[^\"'# ]*[\"']*/\1\"$NEW_TAG\"/g" "$yaml_file"
                              echo "    ✅ Updated tag on line $TAG_LINE"
                              UPDATED_ANY_FILE=true
                              continue
                          fi
                      fi
                  fi
                  
                  # Method 2: Look for single-line image format (image: repository:tag)
                  IMAGE_LINES=$(grep -n "image:\|value:" "$yaml_file" 2>/dev/null)
                  
                  if [ -n "$IMAGE_LINES" ]; then
                      # Use process substitution to avoid subshell issue
                      while IFS=: read -r line_num line_content; do
                          # Check if this line contains the repository (fuzzy match)
                          if echo "$line_content" | grep -q "$REPOSITORY"; then
                          echo "    Found single-line image format in $yaml_file at line $line_num: $line_content"
                              # Handle formats like: image: repo:tag, image: "repo:tag", image: 'repo:tag'
                              # Use sed to replace the tag part, preserving quotes and whitespace
                              sed -i "${line_num}s/\(image:.*$REPOSITORY:\|value:.*$REPOSITORY:\)[^\"'[:space:]]*/\1$NEW_TAG/g" "$yaml_file"
                              echo "    ✅ Updated image tag on line $line_num"
                              UPDATED_ANY_FILE=true
                          fi
                      done < <(echo "$IMAGE_LINES")
                  fi
              done < <(echo "$YAML_FILES")

              if [ "$UPDATED_ANY_FILE" = "false" ]; then
                  echo "    ⚠️  Repository '$REPOSITORY' not found in any YAML files"
              fi
          done

          echo ""
          echo "Updated repository and tag occurrences:"
          echo "$YAML_FILES" | while read -r yaml_file; do
              if [ -f "$yaml_file" ]; then
                  echo "=== $yaml_file ==="
                  grep -n -A1 -B1 "repository:\|tag:\|image:" "$yaml_file" 2>/dev/null || echo "No repository/tag/image entries found"
                  echo ""
              fi
          done
          
      - name: Check if changes were made
        id: check_changes
        run: |
          if git diff --quiet; then
            echo "No changes were made to the files"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected:"
            git diff
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi

      - name: Git add
        if: steps.check_changes.outputs.changes_made == 'true'
        run: |
          git add "${{ steps.parse_payload.outputs.env }}/"
          
      - name: Commit signed
        uses: fhiskybert/actions--create-commit@v1
        if: steps.check_changes.outputs.changes_made == 'true'
        id: commit
        with:
          message: "Update tags in ${{ steps.parse_payload.outputs.env }} environment"
          
      - name: push
        if: steps.check_changes.outputs.changes_made == 'true'
        run: |
          git push
     
      - name: Summary
        run: |
          if [ "${{ steps.check_changes.outputs.changes_made }}" == "true" ]; then
            echo "✅ Successfully updated repository tags in ${{ steps.parse_payload.outputs.env }}"
            UPDATES_JSON='${{ steps.parse_payload.outputs.updates }}'
            echo "Updates applied:"
            echo "$UPDATES_JSON" | jq -r '.[] | "  ✓ \(.repository) -> \(.tag)"'
          else
            echo "ℹ️ No changes were needed - all tags may already be set to the specified values"
          fi
          
      - name: Trigger OCI push workflow
        if: steps.check_changes.outputs.changes_made == 'true'
        run: |
          echo "Triggering OCI push workflow to rebuild manifests..."
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/oci-push.yaml/dispatches \
            -d '{"ref":"main"}'
